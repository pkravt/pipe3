#summary Список грядущих изменений в программе.

=ОБЩИЕ ВОПРОСЫ=

 *. если последний сегмент прямой и вертикальный сверху вниз, то бак надо смещать по горизонтали на (радиус бака+радиус трубы), а то смотрится плохо
 * обсудить еще раз H-соединения и ЗАПИСАТЬ мысли 
 *  сделать расчет внезапных сужений/расширений
 *  Обратить внимание, что боковые ветки с расходным баком должны считаться "наоборот", т.е. топливо течет от старших сегментов к младшим. варианты решения:
 #  перевернуть ветку перед расчетом
 #  ввести "внутренний индекс" для каждого сегмента (не индекс массива), и рассчитывать их перед обсчетом трубы
 #  _pk: самое удобное будет сделать функцию `SegNum(NBranch, NSeg)`, которая будет возвращать номер сегмента по направлению потока. На входе - номер бренча и порядковый номер сегмента, который нужно найти. Функция учитывает тип бака. Т.е. для расходного бака в ветке 3 из 10 сегментов `SegNum(3, 1)` вернет сегмент, стоящий перед баком в редакторе._
   _mix: мысль понятная, причем номер ветки можно не использовать, если сделать данную функцию методом класса._
 *  подумать какие функции перенести в класс бренча
 *  каждый параметр расчета сделать в виде двумерного массива `PAR[segment#, time step]` и засунуть его в класс бренча

= БАКИ =
 * были две калибровки баков. теперь баков много, и калибровок может быть много. Т.о., нужен динамический массив калибровок Tanks (каждая калибровка - структура типа TTank).
 * У сегмента бака должно быть свойство `TankType - [Experimental, Cylindrical, Custom]`
 * в случае Custom tank нужно каким-то образом выбирать либо одну из уже загруженных калибровок из массива Tanks, либо загружать новую, с добавлением ее к массиву.

_mix: Только бы не запутаться в типах баков. Есть свойство `SubTypeTank`, которое используется для определения  расходных / принимающих баков. Надо это как-нибудь правильно систематизировать. Кстати, а не лучше направленности потока сопоставить свойство самого бренча?_

_pk: Это разумно. Потому как бак один на всю ветку. т.о. мы сэкономим свойство в каждом сегменте. Проблема в том, что здесь проявится отличие главной ветки от остальных - у главной два бака, у остальных - по одной. Так что придется в классе ветки предусматривать два бака, а использовать в дочерних только один._

Чтобы не запутаться в типах баков резюмирую: у бака есть свойство направления потока (субтайп) и свойство калибровки (тип).

1. субтайпа бака всего два - вход или выход.

2. а вот ТИПА бака три (они не объединяются с подтипами, т.е. один и тот же подтип может быть любым из трех типов).

в случае произвольного типа бака (`TankType=Custom`) у бака должна быть еще калибровка - структура `TTank`. Но в принципе полезно предусмотреть переиспользование уже загруженных структур калибровок, а не требовать на каждый бак свою отдельную структуру.

Тогда имеет смысл добавить в класс ветки свойство `FlowDirection` со значениями `fdSupply=0` и `fdReceive=1`, и массив `Tank[0..1] of TTank`. В структуру `TTank` нужно  добавить свойство типа бака (Experimental, Cylindrical, Custom), и можно перенести туда свойства `Tank_H` и `Tank_D`, хотя это потребует много переделок, но в принципе будет правильным. Тогда вся информация о баке ветки будет сосредоточена в свойстве `Tank[FlowDirection]` для всех веток, включая главную. Единственная сложность, которую я пока вижу - это при смене `FlowDirection` ветки придется копировать структуру `Tank`.

_mix: Вместо `Tank[FlowDirection]` будет использоваться следующая конструкция `TankGetTankIndex(TubeIndex)]`. Здесь: `GetTankIndex()` - метод класса Branch, `TubeIndex` - индекс текущего сегмента._
----
[[[
Function TBranch.GetTankIndex(TubeIndex:Integer):Byte;
begin
  if Bnum = 0 then Result:=sign(TubeIndex) else Result := FlowDirection;
end;
]]]
----


=РЕДАКТОР СЕГМЕНТОВ=

 *[+ в редакторе сегментов - такое же дерево как в основном окне, но с редактированием имен сегментов и бренчей. 
 *[+ в заголовке окна отображать бренч (кроме сегмента)
 *[+ сделать два типа баков - supply & receiving. Вставить подтип бака в редактор сегментов.
 *[+ разные типы баков отображать разным цветом.
 *[+. отображать угол присоединения бренча вместо редактора сегмента при выделении бренча в дереве. там же отображать свойства бренча: полная длина, кол-во сегментов...
 *. придумать куда деть результаты расчета и убрать их из редактора каркаса. 

 _mix: Основные результаты моделирования можно отображать по щелчку кнопки “Results”, расположенной в правом углу статусбара_
 *[+. подсвечивать выделенную точку каркаса. 
 _mix:(???) Подсвечивать точки следует не в редакторе, а в главном окне (fmMain)_
 *[+. подсветить выделенный в дереве сегмент. 
 _mix: Остановился на каркасном выделении сегмента. Принцип действия достаточно прост: берем соответствующий меш, копируем, самую малость масштабируем, меняем цвет вершин и задаем режим отображения полигонов - pmLines.  _


=ГРАФИК ПО СЕГМЕНТАМ=
 *. убить bar series - переделать на линии
 *. добавить выпадающий список веток. 
 _mix: Вместо выпадающего списка будет доступна палитра бренчей, для которой в данном режиме дочерние узлы (сегменты) свернуты._
 *. расходные ветки отображать "наоборот" !!! (см. дальше про их расчет)
 *. подумать о графике со всеми ветками вместе (боковые рисуются вместе с главной)
 *. отображать ветку в заголовке

=TIME CHART=
 *. вставить такое же дерево веток и сегментов как в основном окне

=EXPORT=
 *[+. каждый бренч экспортируется в отдельный файл
 *[+. имена файлов: pipename.BRANCH_00.xls
 *[+. пользователь вводит только имя фолдера (pipename), куда сваливаются все эти файлы.
 * Подумать что делать с баками. _pk: над этим я подумаю._

=UNDO / REDO =

=)