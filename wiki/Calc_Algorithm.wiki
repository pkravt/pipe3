#summary Алгоритм расчета трубопровода

= Алгоритм расчета трубопровода =

== Критерий годности разветвленного трубопровода ==

Начальная формулировка критерия расчитываемости трубопровода звучит так:
*В трубопроводе должен быть сегмент, через который проходит поток из любого расходного бака в любой приемный, и только через него.*
Таких сегментов может быть много. Но важно, чтобы был хотя бы один такой сегмент.

Другая формулировка позволяет алгоритмизировать анализ трубопровода:
Определим тип сегмента соединения ветвей (*джойнта*):

 * S-joint - сегмент, к которому присоединены расходные ветки;
 * R-joint - сегмент, к которому присоединены приемные ветки;
 * M-joint - сегмент, в котором сходятся ветки разнонаправленных потоков.

Тогда правила годности трубопровода для расчета можно записать так:
 # На ВСЕХ ветках нет ни одного М-сегмента.
 # К каждому джойнту главной ветки, должны быть присоединены только однотипные по направлению потока ветки, включая всех их дочек.
 # В последовательности соединительных сегментов на главной ветки изменение Joint-типа может произойти только в порядке S->R.

При этом все обычные (не джойнт) сегменты между последним S-джойнтом и первым R-джойнтом на главной ветке как раз и являются теми сегментами, о которых говорилось в начальной формулировке критерия. Назовем из *сегментами полного потока*. Именно их мы будем использовать как стартовые для расчетов.


== CalcJoint ==

Для простоты предположим, что у нас есть функция (*CalcJoint*), расчитывающая соединение ветвей (*джойнт*). Для работы этой функции будет необходимо начальное приближение, которое считается для обычного потока в неразветвленной ветви, в которой находится данное соединение.

Для примера рассмотрим входной поток из supply бака, т.е. случай с расходными ветвями в джойнте на главной ветке. Можно рассматривать такой джойнт как соединение нескольких расходных ветвей с одной приемной. Одна из расходных ветвей в данном случае является частью главной ветви. Единственная приемная ветвь - тоже часть главной.

Запустив CalcJoint для такого джойнт-сегмента главного трубопровода, мы получим параметры потока для всех боковых ветвей, присоединенных в этот джойнт, а также уточненные параметры расходной части главной ветви, которая расположена до джойнта. Расход топлива через расходную часть главной ветви остается неизменным, однако давление в начале расходной ветви, т.е. сразу после соединения, изменяется по результатам расчета CalcJoint.

Внутри CalcJoint предполагается, что все ветви, присоединенные к рассматриваемому джойнту, являются обычными трубопроводами без дополнительных разветвлений. Т.е. джойнт-сегменты боковых ветвей не учитываются.


== Рекурсивный обсчет дерева ==

Начинать расчет будем с *сегмента полного потока*. У нас есть начальное приближение, которое для нашего расчета считается по главной ветви из расходного бака в приемный, игнорируя все ветвления. Кроме того, на этапе тестов и анализа трубопровода мы нашли хотя бы один *сегмент полного потока* (или забраковали трубопровод, запретив его расчет).
Расчет выполняется с помощью функции Walk_Calc:

Функция Walk_Calc (параметры: базовая ветка для расчета, стартовый сегмент в ней, направление обхода (вверх или вниз по потоку)):
 # Начиная со стартового сегмента, перебираем сегменты базовой ветви (ветвь нулевого порядка) в направлении обхода в поисках джойнт-сегмента.
 # Найдя соединение ветвей, вызываем для него функцию CalcJoint.
 # По результатам работы CalcJoint обновляется давление после соединения, а также параметры потока в части главной ветви до этого соединения. Таким образом, после этого шага мы имеем параметры течения для всех боковых ветвей, присоединенных к данному джойнту.
 # При наличии джойнт-сегментов в боковых ветвях нашего соединения (ветви первого порядка) вызываем рекурсивно Walk_Calc для каждой из таких ветвей с джойнтами. Параметры Walk_Branch: боковая ветка первого порядка с джойнтом будет базовой для этого вызова, стартовый сегмент - первый сегмент этой боковой ветки, направление обхода - без изменений.
 # По результатам расчетов всех соединений "высшего порядка" обновляются давления после джойнт-сегментов ветвей первого порядка. Вероятно, это потребует некого пересчета параметров потока в этих ветвях (вопрос к Кате).
 # Перебираем сегменты базовой ветки в поисках джойнт-сегментов. Найдя таковой, переходим к п. 2.

Таким образом, на шаге 4 обходятся рекурсивно всё поддерево трубопроводов, присоединенное к рассматриваемому джойнт-сегменту. При этом на каждом рекурсивном шаге у расчетной функции будет начальное приближение, посчитанное для одной из ветвей (базовая ветка в параметрах Walk_Calc). 

Для расчета всей расходной половины любого трубопровода достаточно вызвать Walk_Calc с параметрами: главная ветка, любой *сегмент полного потока*, направление обхода - вверх по потоку. Аналогично, для приемной половины трубопровода вызывается Walk_Calc с такими же параметрами, но с направлением вниз по потоку.


== Рекурсивный обсчет дерева ==

http://lkst.pnpi.nw.ru/tmp/my/AIRBUS/branches_calc.png

После расчета дочерних ветвей требуется обновлять параметры потока в базовых частях. Например, после расчета соединения J2 нужно обновить параметры потока в части (1) ветви 1, т.к. в частях (2) и (3) поток изменился и в части (1) скорость потока вырастет за счет подпитки из ветвей 2 и 3. Чтобы избежать вложенной рекурсии (обхода дерева «вверх» в UpdateJoint внутри рекурсии CalcWalkBranch), это обновление сделано с задержкой на одну глобальную итерацию по следующему алгоритму. При обходе дерева в функциях Calc_Branch_Loss и Calc_BranchPart_Loss используется флаг CalcLosses, который вначале равен True, а потом на джойнт-сегменте может стать False, если это не нулевая глобальная итерация. Таким образом:

 # После вычисления нулевого приближения для главной ветви начинается глобальный итерационный цикл. 
 # В нулевой глобальной итерации (N_ITER_G=0) все ветви считаются полностью. Т.е. при расчете джойнта J1 ветвь 1 считается целиком, а при расчете джойнта J2 у ветви 1 считаются потери и скорости в частях (2) и (3).
 # В ненулевой глобальной итерации (N_ITER_G>0) потери и скорости пересчитываются только ДО следующих джойнт-сегментов. При этом при расчете джойнта J1 ветвь 1 будет пересчитываться только в части (1), а при расчете J2 – только в части (2) (на основе потока в части(1)). 
 # Во время следующей глобальной итерации при расчете J1 параметры потока в части (1) ветви 1 обновятся, поскольку при расчете давлений во всей ветви (в функциях Calc_XXXPart_Pniv_Dens) используются потери давления для различных потоков в частях (1), (2) и (3). В итоге получим различные скорости и потери в частях (1), (2), (3), и давления пересчитываются в этих частях с задержкой на одну глобальную итерацию.



.