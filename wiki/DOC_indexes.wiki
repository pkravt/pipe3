#summary Определения массивов и индексов.

= Определения индексов и прочей нечисти =

== Ветки, сегменты и баки ==

Класс ветки - `TBranch` - включает в себя все основные
методы для обработки и отрисовки трубопровода, а также массив сегментов `Tube`.
Основной массив веток - `Branch[]`. Количество веток - BranchesNum. Таким образом, последняя ветка представлена в `Branch[BranchesNum-1]`.
Нулевой элемент массива - основная ветка.
Она отличается от дочерних тем, что всегда имеет два бачка - входной 

`Branch[0].Tube[0]`, и выходной 

`Branch[BranchesNum-1].Tube[Branch[BranchesNum-1].ObjectsNum-1]`. 

Дочерние ветки имеют только один бачок:

`Branch[].Tube[Branch[].ObjectsNum-1]`. 

Нулевой элемент `Tube[0]` для всех боковых веток - фиктивный Joint-сегмент. Его надо игнорировать в расчетах.

Тип дочерней ветки (расходная или приемная) и, соответственно, ее бака, может быть получен методом

`Branch[].FlowDirection`, которое может принимать значения `fdSupply` или `fdReceive`.

Для правильной нумерации индексов сегментов сделана функция:

`Branch[].GetTubeIndex(TubeIndex): integer`,

которая возвращает индекс сегмента в зависимости от заданного порядкового номера и направления потока в ветке. Т.е. для ветки с `FlowDirection=fdReceive` эта функция возвращает `TubeIndex`, а для ветки с `FlowDirection=fdSupply` - индекс с конца ветки, т.е. в этом случае 

`Branch[].Tube[GetTubeIndex(0)]` - это расходный бак ветки.

Таким образом, поток всегда течет из 

`Branch[].Tube[GetTubeIndex(0)]` в `Branch[].Tube[GetTubeIndex(1)]`

Реально в расчетах `GetTubeIndex` не используется. Вместо этого сделаны другие полезные функции:

{{{
Inlet(i)      - индекс сечения на входе потока в сегмент i
Outlet(i)     - индекс сечения на выходе потока из сегмента i
D_Inlet(i)    - диаметр трубы на входе потока в сегмент i
D_Outlet(i)   - диаметр трубы на выходе потока из сегмента i
Downstream(i) - индекс сегмента следующего по потоку после сегмента i
Upstream(i)   - индекс сегмента предыдущего по потоку перед сегментом i}}}





<br><br><br><br>

== Индексы и массивы для обхода дерева веток ==

*JointSegment* - свойство ветки - массив индексов сегментов с присоединенными ветками (т.н. Joint-сегментов). Нулевой элемент массива указывает на первый по счету joint-сегмент в средней части ветки, т.е.  между 1 и ObjectsNum-2. Массив перестраивается каждый раз при деформации каркаса. Хотя тут можно подумать и оптимизировать, но на данный момент это не приоритетно.

*JointBranch* - свойство сегмента - массив индексов дочерних веток, присоединенных к данному joint-сегменту. Для не-joint-сегментов этот массив пуст. Нулевой элемент массива указывает на первую по счету дочернюю ветку.

_Эти массивы необходимы для обхода дерева "сверху" - от базовой ветки к дочерним._

*ParentBranch* - свойство ветки - индекс родительской ветки. Для корневой (основной) ветки он равен "-1".

*ParentSegment* - свойство ветки - индекс сегмента в родительской ветке, куда присоединена данная ветка. Ссылается на элемент трубы, а не на JointSegment. Корректируется (для дочерних веток) в процедуре копирования свойств сегмента. Для корневой ветки ParentSegment также равен "-1". Для отслеживания изменений в каркасе, наверное, удобнее будет ссылаться через JointSegment, иначе придется пробегать по дочерним веткам при изменении числа сегментов. Тогда массив "соседних" или "братских" веток для любой дочерней определяется по элементам массива:

`Branch[ParentBranch].Tube[  Branch[ParentBranch].JointSegment[ParentSegment] ].JointBranch []`

При этом надо не забыть про изменение массива JointSegment при изменении числа сегментов.

_Эти индексы необходимы для построения массивов  JointSegment/JointBranch, обхода дерева "снизу", а также для отображения дерева в палитре веток._

Функция TBranch.IsJoint(i) активно используется при расчетном обходе дерева. Она возвращает True, только если индекс соответствует джойнт-сегменту _с видимыми боковыми ветками_.



<br><br><br><br>

== Массивы результатов вычислений ==

Все массивы перенесены в класс TBranch, т.е. доступ к ним осуществляется через 

`Branch[].Loss_friction[SegmentIndex]` или

`Branch[].tLoss_friction[TimeStep, SegmentIndex]`.

Надо подумать о переносе нестационарных результатов для все трубы, которые не зависят от номера сегмента, а именно: уровень топлива в баке, flowrate, velocity.