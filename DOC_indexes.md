# Определения индексов и прочей нечисти #

## Ветки, сегменты и баки ##

Класс ветки - `TBranch` - включает в себя все основные
методы для обработки и отрисовки трубопровода, а также массив сегментов `Tube`.
Основной массив веток - `Branch[]`. Количество веток - BranchesNum. Таким образом, последняя ветка представлена в `Branch[BranchesNum-1]`.
Нулевой элемент массива - основная ветка.
Она отличается от дочерних тем, что всегда имеет два бачка - входной

`Branch[0].Tube[0]`, и выходной

`Branch[BranchesNum-1].Tube[Branch[BranchesNum-1].ObjectsNum-1]`.

Дочерние ветки имеют только один бачок:

`Branch[].Tube[Branch[].ObjectsNum-1]`.

Нулевой элемент `Tube[0]` для всех боковых веток - фиктивный Joint-сегмент. Его надо игнорировать в расчетах.

Тип дочерней ветки (расходная или приемная) и, соответственно, ее бака, может быть получен методом

`Branch[].FlowDirection`, которое может принимать значения `fdSupply` или `fdReceive`.

Для правильной нумерации индексов сегментов сделана функция:

`Branch[].GetTubeIndex(TubeIndex): integer`,

которая возвращает индекс сегмента в зависимости от заданного порядкового номера и направления потока в ветке. Т.е. для ветки с `FlowDirection=fdReceive` эта функция возвращает `TubeIndex`, а для ветки с `FlowDirection=fdSupply` - индекс с конца ветки, т.е. в этом случае

`Branch[].Tube[GetTubeIndex(0)]` - это расходный бак ветки.

Таким образом, поток всегда течет из

`Branch[].Tube[GetTubeIndex(0)]` в `Branch[].Tube[GetTubeIndex(1)]`

Реально в расчетах `GetTubeIndex` не используется. Вместо этого сделаны другие полезные функции:

```
Inlet(i)      - индекс сечения на входе потока в сегмент i
Outlet(i)     - индекс сечения на выходе потока из сегмента i
D_Inlet(i)    - диаметр трубы на входе потока в сегмент i
D_Outlet(i)   - диаметр трубы на выходе потока из сегмента i
Downstream(i) - индекс сегмента следующего по потоку после сегмента i
Upstream(i)   - индекс сегмента предыдущего по потоку перед сегментом i
```





<br><br><br><br>

<h2>Индексы и массивы для обхода дерева веток</h2>

<b>JointSegment</b> - свойство ветки - массив индексов сегментов с присоединенными ветками (т.н. Joint-сегментов). Нулевой элемент массива указывает на первый по счету joint-сегмент в средней части ветки, т.е.  между 1 и ObjectsNum-2. Массив перестраивается каждый раз при деформации каркаса. Хотя тут можно подумать и оптимизировать, но на данный момент это не приоритетно.<br>
<br>
<b>JointBranch</b> - свойство сегмента - массив индексов дочерних веток, присоединенных к данному joint-сегменту. Для не-joint-сегментов этот массив пуст. Нулевой элемент массива указывает на первую по счету дочернюю ветку.<br>
<br>
<i>Эти массивы необходимы для обхода дерева "сверху" - от базовой ветки к дочерним.</i>

<b>ParentBranch</b> - свойство ветки - индекс родительской ветки. Для корневой (основной) ветки он равен "-1".<br>
<br>
<b>ParentSegment</b> - свойство ветки - индекс сегмента в родительской ветке, куда присоединена данная ветка. Ссылается на элемент трубы, а не на JointSegment. Корректируется (для дочерних веток) в процедуре копирования свойств сегмента. Для корневой ветки ParentSegment также равен "-1". Для отслеживания изменений в каркасе, наверное, удобнее будет ссылаться через JointSegment, иначе придется пробегать по дочерним веткам при изменении числа сегментов. Тогда массив "соседних" или "братских" веток для любой дочерней определяется по элементам массива:<br>
<br>
<code>Branch[ParentBranch].Tube[  Branch[ParentBranch].JointSegment[ParentSegment] ].JointBranch []</code>

При этом надо не забыть про изменение массива JointSegment при изменении числа сегментов.<br>
<br>
<i>Эти индексы необходимы для построения массивов  JointSegment/JointBranch, обхода дерева "снизу", а также для отображения дерева в палитре веток.</i>

Функция TBranch.IsJoint(i) активно используется при расчетном обходе дерева. Она возвращает True, только если индекс соответствует джойнт-сегменту <i>с видимыми боковыми ветками</i>.<br>
<br>
<br>
<br>
<br><br><br><br>

<h2>Массивы результатов вычислений</h2>

Все массивы перенесены в класс TBranch, т.е. доступ к ним осуществляется через<br>
<br>
<code>Branch[].Loss_friction[SegmentIndex]</code> или<br>
<br>
<code>Branch[].tLoss_friction[TimeStep, SegmentIndex]</code>.<br>
<br>
Надо подумать о переносе нестационарных результатов для все трубы, которые не зависят от номера сегмента, а именно: уровень топлива в баке, flowrate, velocity.